# Expansion Beyond the JVM Ecosystem

The ecosystem of the Java Virtual Machine (JVM) is a comprehensive and elaborate system that has been meticulously crafted over several decades. It boasts a vast array of tools, libraries, and frameworks that are well-suited to handle a wide range of tasks and architectures, enabling the creation of intricate and scalable applications that can seamlessly operate on numerous platforms and devices. Nonetheless, it is imperative to recognise that options outside the JVM ecosystem may offer superior performance, ergonomics, or community adoption. So, while the JVM ecosystem is robust, it may not always be the best choice for every use case. Thus, broadening one's perspective and exploring alternative technologies or platforms that may provide better solutions is paramount.

An illustrative instance where this approach may prove exceptionally advantageous pertains to the performance and ergonomics of hashing functions requisite for license classification during the scanning process. Despite the abundance of performance-optimised hashing functions and general optimisation techniques available within the JVM ecosystem, they may not suffice in this particular scenario. As a result, it becomes imperative to examine solutions that leverage hardware-accelerated approaches to handle the requisite data throughput or those that have comprehensively implemented and tested specific hashing functions with favourable collision properties.

Adopting non-JVM-byte-code-based technology ecosystems, such as C, C++, or Rust, requires a careful balancing act of innumerable factors that can have significant implications on the application deployment process and native packaging via GraalVM. While such technologies may offer better ergonomics in certain situations, they can also introduce complexities and potential errors when interfacing with the JVM. Moreover, non-JVM technologies may lack the same level of support as Java, resulting in difficulties when seeking assistance for issues that arise, leading to increased development cycles and costs. Therefore, it is crucial to meticulously evaluate the potential benefits and drawbacks of non-JVM technologies and consider their impact, ensuring that the chosen approach aligns with the project requirements and objectives while minimising any adverse effects.

To ameliorate the risks that arise from the use of non-JVM technologies, software developers can employ the Java Native Interface (JNI). This interface offers a standard approach to interfacing with native code written in other languages. Furthermore, more high-level developer-friendly abstractions to the JNI, such as the Java Native Runtime Project (JNR) and Java Native Access (JNA), are available. However, the future presents an even more promising prospect for the development of Java's native interoperability capabilities, with Project Panama spearheading the charge. This visionary and groundbreaking incubator initiative seeks to enhance the safety, efficiency, and modernity of interfacing with non-JVM technologies.

The Foreign Function & Memory (FFM) API, a proposal by Project Panama, offers Java programs the capability to interoperate with code and data outside the Java runtime seamlessly. This API efficiently invokes foreign functions and enables safe access to foreign memory, outpacing existing APIs such as JNI and sun.misc.Unsafe, while utilising a superior, pure-Java development model. Additionally, the project aims to provide tools that can mechanically generate Java code from native-code header files and modify how Java applications interact with native libraries in terms of packaging and deployment without intending to replace the existing JNI or re-implement legacy Java APIs such as sun.misc.Unsafe.

Therefore, despite not serving as a panacea for all the abovementioned issues, the Foreign Function & Memory (FFM) API proposed by Project Panama represents an available tool worth exploring to enable further opportunities. Nevertheless, it is also vital to remember that every architectural decision needs to be made with all the mentioned factors in mind to guarantee that the platform's scalability is not adversely affected.
